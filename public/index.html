<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hero Pong Live</title>
    <style>
        :root { --accent: #4CAF50; }
        body { 
            margin: 0; background: #111; color: #eee; 
            font-family: 'Courier New', Courier, monospace;
            display: flex; flex-direction: column; align-items: center; 
            justify-content: center; height: 100vh; width: 100vw;
            overflow: hidden; touch-action: none; 
        }
        
        #game-container { 
            position: relative; 
            width: 95vw; 
            max-width: 800px;
            max-height: 90vh; /* Prevents overflow in landscape */
            aspect-ratio: 2 / 1; 
            border: 2px solid #333;
            background: #222;
        }
        
        canvas { width: 100%; height: 100%; display: block; }

        /* Overlays */
        #loading-overlay, #win-overlay, #orientation-overlay {
            position: absolute; inset: 0; background: #111;
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; z-index: 100; text-align: center;
        }

        #orientation-overlay { display: none; z-index: 200; }
        @media (orientation: portrait) { #orientation-overlay { display: flex; } }

        .spinner {
            width: 40px; height: 40px; border: 4px solid #333;
            border-top: 4px solid var(--accent); border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Scoreboard */
        .scoreboard {
            position: absolute; top: 10%; width: 100%;
            display: flex; justify-content: center;
            font-size: clamp(24px, 6vw, 60px); font-weight: bold;
            color: rgba(255, 255, 255, 0.15); pointer-events: none;
        }

        #ui-layer {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 15px;
        }
        .status { background: rgba(0, 0, 0, 0.8); padding: 5px 12px; border-radius: 4px; font-size: 10px; }
        
        .btn {
            background: #fff; border: none; padding: 12px 20px; 
            font-weight: bold; cursor: pointer; border-radius: 4px; font-family: inherit;
            pointer-events: auto;
        }
        
        #toast { 
            background: #333; padding: 15px; border: 1px solid #555; 
            border-radius: 8px; display: none; pointer-events: auto;
        }

        #visitor-stats {
            position: absolute; bottom: 10px; right: 15px;
            display: flex; align-items: center; gap: 5px; font-size: 10px; color: #666;
        }
        .live-dot { width: 6px; height: 6px; background: #ff4444; border-radius: 50%; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
    </style>
</head>
<body>

    <div id="orientation-overlay">
        <p>ðŸ”„ Please rotate to Landscape</p>
    </div>

    <div id="loading-overlay">
        <div class="spinner"></div>
        <div>Waking up server...</div>
    </div>

    <div id="win-overlay" style="display: none; z-index: 150;">
        <h1 id="win-message">P1 WINS!</h1>
        <button class="btn" onclick="socket.emit('request_rematch')">REMATCH</button>
        <button class="btn" onclick="location.reload()" style="margin-top: 10px; background: #444; color: white;">QUIT</button>
    </div>

    <div id="game-container">
        <div class="scoreboard">
            <span id="score-p1">0</span><span style="margin: 0 15px;">:</span><span id="score-p2">0</span>
        </div>

        <canvas id="pongCanvas" width="800" height="400"></canvas>
        
        <div id="ui-layer">
            <div style="text-align: center;">
                <span id="status-text" class="status">Connecting...</span>
                <div id="toast" style="margin-top: 10px;">
                    <p style="margin: 0 0 10px 0;">New Challenger!</p>
                    <button class="btn" onclick="acceptChallenge()" style="background: var(--accent); color: white;">ACCEPT</button>
                </div>
            </div>
            
            <div id="challenge-area" style="text-align: center; display: none;">
                <button class="btn" onclick="sendChallenge()">CHALLENGE HOST</button>
            </div>
        </div>

        <div id="visitor-stats">
            <div class="live-dot"></div>
            <span id="visitor-text">1 VISITOR</span>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const statusText = document.getElementById('status-text');
        const challengeArea = document.getElementById('challenge-area');
        const toast = document.getElementById('toast');
        const winOverlay = document.getElementById('win-overlay');

        // Game State
        let myRole = null; let isPVP = false; let gameActive = true;
        let challengerSocketId = null;
        let ball = { x: 400, y: 200, dx: 4, dy: 4 };
        let playerY = 160; let opponentY = 160;
        let scoreP1 = 0; let scoreP2 = 0;

        // Input Logic
        function handleInput(y) {
            if (!gameActive) return;
            const rect = canvas.getBoundingClientRect();
            const scaleY = 400 / rect.height;
            const targetY = (y - rect.top) * scaleY - 40;
            
            if (myRole === 'HOST') playerY = targetY;
            else if (myRole === 'CHALLENGER') socket.emit('p2_move', targetY);
        }

        canvas.addEventListener('mousemove', (e) => handleInput(e.clientY));
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            handleInput(e.touches[0].clientY);
        }, { passive: false });

        // Socket Logic
        socket.on('connect', () => {
            document.getElementById('loading-overlay').style.display = 'none';
        });

        socket.on('role', (role) => {
            myRole = role;
            updateUI();
        });

        socket.on('visitor_count', (count) => {
            document.getElementById('visitor-text').innerText = count === 1 ? "1 VISITOR" : `${count} VISITORS`;
        });

        socket.on('challenge_received', (id) => {
            if (myRole === 'HOST') {
                challengerSocketId = id;
                toast.style.display = 'block';
            }
        });

        socket.on('challenge_pending', () => {
            statusText.innerText = "Challenge Sent...";
            challengeArea.style.display = 'none';
        });

        socket.on('game_mode_change', (data) => {
            isPVP = true; gameActive = true;
            if (data.challengerId === socket.id) myRole = 'CHALLENGER';
            winOverlay.style.display = 'none';
            toast.style.display = 'none';
            updateUI();
        });

        socket.on('spectator_update', (state) => {
            if (myRole !== 'HOST') {
                ball = state.ball; playerY = state.playerY; opponentY = state.opponentY;
                scoreP1 = state.scoreP1; scoreP2 = state.scoreP2;
                updateScoreboard();
            }
        });

        socket.on('p2_update', (y) => { if (myRole === 'HOST') opponentY = y; });

        socket.on('game_over', (data) => {
            gameActive = false;
            winOverlay.style.display = 'flex';
            document.getElementById('win-message').innerText = data.winner === 'P1' ? 'LEFT WINS!' : 'RIGHT WINS!';
        });

        socket.on('rematch_started', () => {
            scoreP1 = 0; scoreP2 = 0; gameActive = true;
            winOverlay.style.display = 'none';
            updateScoreboard();
        });

        socket.on('reset_game', () => location.reload());
        socket.on('challenger_left', () => { isPVP = false; updateUI(); });

        // Helper Functions
        function updateUI() {
            if (myRole === 'HOST') statusText.innerText = isPVP ? "PVP Match" : "Playing AI";
            else if (myRole === 'CHALLENGER') statusText.innerText = "Challenger (Right)";
            else {
                statusText.innerText = "Spectating";
                challengeArea.style.display = isPVP ? 'none' : 'block';
            }
        }

        function updateScoreboard() {
            document.getElementById('score-p1').innerText = scoreP1;
            document.getElementById('score-p2').innerText = scoreP2;
        }

        function sendChallenge() { socket.emit('challenge_request'); }
        function acceptChallenge() { socket.emit('accept_challenge', challengerSocketId); }

        function resetBall() {
            ball = { x: 400, y: 200, dx: 4 * (Math.random() > 0.5 ? 1 : -1), dy: 4 };
        }

        // Host Loop
        function update() {
            if (myRole !== 'HOST' || !gameActive) return;

            if (!isPVP) { // AI
                opponentY += (ball.y - 40 - opponentY) * 0.1;
            }

            ball.x += ball.dx; ball.y += ball.dy;
            if (ball.y < 0 || ball.y > 400) ball.dy *= -1;

            if (ball.x < 12 && ball.y > playerY && ball.y < playerY + 80) ball.dx = Math.abs(ball.dx) * 1.05;
            if (ball.x > 788 && ball.y > opponentY && ball.y < opponentY + 80) ball.dx = -Math.abs(ball.dx) * 1.05;

            if (ball.x < 0) { scoreP2++; scoreP2 >= 5 ? socket.emit('match_finished', {winner:'P2'}) : resetBall(); updateScoreboard(); }
            if (ball.x > 800) { scoreP1++; scoreP1 >= 5 ? socket.emit('match_finished', {winner:'P1'}) : resetBall(); updateScoreboard(); }

            socket.emit('host_update', { ball, playerY, opponentY, scoreP1, scoreP2 });
        }

        function draw() {
            ctx.clearRect(0, 0, 800, 400);
            ctx.fillStyle = '#eee';
            ctx.fillRect(0, playerY, 12, 80);
            ctx.fillRect(788, opponentY, 12, 80);
            ctx.beginPath(); ctx.arc(ball.x, ball.y, 8, 0, Math.PI*2); ctx.fill();
            update();
            requestAnimationFrame(draw);
        }

        draw();
    </script>
</body>
</html>